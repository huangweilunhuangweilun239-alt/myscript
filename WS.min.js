(function() {
    'use strict';
 
    // ===================== 可調整參數 =====================
    const MAX_MULTIPLIER       = 25;          // 最高只到 x25，超過自動限縮（防太誇張被 ban）
    const BASE_EXTRA_CHANCE    = 0.70;        // 基礎額外發送機率 (70% → 平均 x1.7)
    const MAX_EXTRA_PER_HIT    = 6;           // 單次攻擊最多額外發幾個（硬上限）
    const MIN_DELAY_MS         = 40;          // 最短延遲
    const MAX_DELAY_MS         = 180;         // 最長延遲（模擬人類不規則）
    const GLOBAL_MSG_LIMIT_PER_SEC = 12;      // 每秒最多發送 checkDamage 總數（包含原本的）
    // ======================================================
 
    // UI ------------------------------------------------------------------------
    function createMultiplierUI() {
        const container = document.createElement('div');
        Object.assign(container.style, {
            position: 'fixed', bottom: '12px', left: '12px', zIndex: '9999',
            background: 'rgba(0,0,0,0.75)', color: 'white', padding: '10px',
            borderRadius: '6px', fontFamily: 'Segoe UI, sans-serif', fontSize: '13px',
            userSelect: 'none', boxShadow: '0 2px 10px rgba(0,0,0,0.6)'
        });
 
        const title = document.createElement('div');
        title.textContent = '低調倍率 (建議≤15)';
        title.style.marginBottom = '6px';
        container.appendChild(title);
 
        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = '1';
        slider.max = MAX_MULTIPLIER;
        slider.value = '1';
        slider.style.width = '220px';
        container.appendChild(slider);
 
        const valueLabel = document.createElement('span');
        valueLabel.textContent = ' ×1';
        valueLabel.style.marginLeft = '10px';
        container.appendChild(valueLabel);
 
        slider.addEventListener('input', () => {
            valueLabel.textContent = ` ×${slider.value}`;
        });
 
        document.body.appendChild(container);
        return slider;
    }
 
    const multiplierSlider = createMultiplierUI();
 
    // 簡單每秒計數器（防止洪水）
    let msgCountThisSecond = 0;
    let lastSecond = Math.floor(Date.now() / 1000);
 
    const originalSend = WebSocket.prototype.send;
    WebSocket.prototype.send = function(data) {
        try {
            let text;
            if (typeof data === 'string') {
                text = data;
            } else if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
                text = new TextDecoder('utf-8').decode(data);
            } else {
                text = String(data);
            }
 
            if (text.includes('Client:EnemyController:checkDamage')) {
                const nowSec = Math.floor(Date.now() / 1000);
                if (nowSec !== lastSecond) {
                    msgCountThisSecond = 0;
                    lastSecond = nowSec;
                }
 
                // 先送原本的
                originalSend.call(this, data);
                msgCountThisSecond++;
 
                const desireMult = parseInt(multiplierSlider.value, 10);
                const targetMult = Math.min(desireMult, MAX_MULTIPLIER);
 
                // 計算這次最多能補幾個
                let maxExtraThisTime = Math.min(
                    MAX_EXTRA_PER_HIT,
                    Math.max(0, Math.floor((GLOBAL_MSG_LIMIT_PER_SEC - msgCountThisSecond) * 0.8))
                );
 
                const extraToSend = Math.min(
                    maxExtraThisTime,
                    Math.floor((targetMult - 1) * BASE_EXTRA_CHANCE + Math.random() * 0.6)
                );
 
                if (extraToSend > 0) {
                    for (let i = 0; i < extraToSend; i++) {
                        const randomDelay = MIN_DELAY_MS + Math.random() * (MAX_DELAY_MS - MIN_DELAY_MS);
                        setTimeout(() => {
                            // 再次檢查是否還在合理範圍
                            const currentSec = Math.floor(Date.now() / 1000);
                            if (currentSec === lastSecond && msgCountThisSecond >= GLOBAL_MSG_LIMIT_PER_SEC) {
                                return; // 這秒已經爆表，丟棄
                            }
                            originalSend.call(this, data);
                            msgCountThisSecond++;
                        }, randomDelay * (i + 1) * 0.7);   // 再乘個係數讓間隔更不規則
                    }
                }
 
                return; // 攔截原本流程
            }
        } catch (e) {
            console.error('[LowRisk KillMult] Error:', e);
        }
 
        // 其他封包正常送
        originalSend.call(this, data);
    };
 
    console.log('[LowRisk Kill Multiplier] 已載入 - 低調模式 v0.2b');
})();
